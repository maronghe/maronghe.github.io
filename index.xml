<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>老干妈</title>
    <link>https://maronghe.github.io/</link>
    <description>Recent content on 老干妈</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Jun 2020 23:52:41 +0800</lastBuildDate>
    
	<atom:link href="https://maronghe.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>#16 限流方案</title>
      <link>https://maronghe.github.io/post/%E9%99%90%E6%B5%81/</link>
      <pubDate>Mon, 15 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/%E9%99%90%E6%B5%81/</guid>
      <description>限流
   定时清除 （1分钟一清除）
 实现简单 对于边界值，如59秒和下一秒会有问题，会得到一个请求限制速率的2倍    滑动窗口（10秒一清除）
 是定时清除的一个优化，缩小了清除粒度但是还是有问题。    漏桶算法 （桶容量 + 桶流速度） https://github.com/uber-go/ratelimit
​	- 超过桶的容量就要涉及到排队或拒绝了
 不支持小流量激增    令牌桶算法（定时放入桶中令牌） https://github.com/juju/ratelimit
 支持小流量并发激增    分布式限流则可用于 Redis + Lua脚本实现，其原理几乎差不多。
local key = &amp;#34;rate.limit:&amp;#34; .. KEYS[1] --限流KEY local limit = tonumber(ARGV[1]) --限流大小 local current = tonumber(redis.call(&amp;#39;get&amp;#39;, key) or &amp;#34;0&amp;#34;) if current + 1 &amp;gt; limit then --如果超出限流大小 return 0 else --请求数+1，并设置1秒过期 redis.</description>
    </item>
    
    <item>
      <title>#15 数组和切片</title>
      <link>https://maronghe.github.io/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</link>
      <pubDate>Sun, 07 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</guid>
      <description>数组和切片的区别
  底层结构 创建  var make []int{}   slice扩容 复用底层数组  注意：
 array不能跟nil比较，编译报错 make只能用于 map， channel ，slice的创建，不能创建数组 var arr [5]int 创建数组，初始化为5个零  ​
 数组大小不可变，切片可变 kind 数组 array [2]int , [3]int[] slice slice []int copy 仅能用于slice，并且dst必须要有容量 复用底部数组 t3 := t1[2:4] // 左闭右开 创建  var arr []int // arr == nil true make &amp;amp; []int{} // arr != nil true    arr := [2]int{1, 3} fmt.</description>
    </item>
    
    <item>
      <title>#14 defer different</title>
      <link>https://maronghe.github.io/post/defer-1.12-vs-1.13-vs-1.14/</link>
      <pubDate>Mon, 01 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/defer-1.12-vs-1.13-vs-1.14/</guid>
      <description>Defer 1.12 vs 1.13 vs 1.14
 1.12之前 defer func(){} —&amp;gt; 会被翻译成两个函数
  deferproc() : 注册，defer func(){} 到g的defer链表中，头插法。defer需要进行堆分配，而且参数变量需要进行堆栈间拷贝。
  runtime.deferreturn() : 执行，defer链表的中的每一项
（先注册 -》 后执行）
// runtime/runtime2.go type g struct { ... _panic *_panic _defer *_defer // defer 链表  ... }   步骤解析：
deferproc
 从defer pool预分配不同规格的defer，不满足时再创建，用完再放回池中。 进行堆分配_defer结构体，将参数拷贝到堆上 连接到g的defer链表上  runtime.deferreturn
 执行defer注册的funcval，将堆上的参数拷贝到栈上，进行执行。  注意：
 若其中有发现闭包，堆上分配捕获变量的地址，执行时通过指针加偏移量找到被捕获的变量进行操作 形如defer A(B(a))  函数A需要依赖B的返回值进行堆分配内存大小 所以B函数在注册时候执行，传入变量啊    存在问题：（慢!</description>
    </item>
    
    <item>
      <title>#12 二叉搜索树（BST）In Go</title>
      <link>https://maronghe.github.io/post/12/</link>
      <pubDate>Tue, 19 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/12/</guid>
      <description>二叉搜索树（Binary Search Tree In Go）
 ​	二搜索树叉树特点：
  极端情况下会退化成链表。
  中序遍历是递增的。
  父节点的左孩子都小于父节点，又孩子都大于父节点
  时间复杂度：
  Talk is cheap, show me the code
源码：https://github.com/maronghe/basego/blob/master/ds/binary_search_tree.go
binary_search_tree.go
/* * Copyright (c) 2020 RongHe Ma. * Recording from daily work flow. */ package ds import ( &amp;#34;fmt&amp;#34; ) // BST Node type Node struct { data int count int left *Node right *Node } func NewBinarySearchTree(data int) *Node { return &amp;amp;Node{data, 1, nil, nil} } func (node *Node)Insert(data int) *Node { return _insert(node,data) } func _insert(root *Node, data int) *Node{ if root == nil { return NewBinarySearchTree(data) } if root.</description>
    </item>
    
    <item>
      <title>#11 Docker In Hour</title>
      <link>https://maronghe.github.io/post/11/</link>
      <pubDate>Sun, 17 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/11/</guid>
      <description>Docker
 一个统一环境dev/qa/app/beta/cloud的容器、容器是相互隔离的。
Docker是容器技术，解决软件跨环境的迁移的问题。
Docker安装后，在本地一守护进程(Daemon)的方式后台运行。
-&amp;gt; docker -v Docker version 19.03.8, build afacb8b 本地部署的分为image和container，image相当于类，container相当于对象，一个类可以创建多个对象。
image 可来自于docker官方Repository Docker Hub 和 private Repository或阿里云镜像 TODO
镜像命令
docker images // 查看当前已安装的镜像列表 docker search [redis] // 搜索redis镜像 docker pull [redis]:[version] // 不指定version默认下载latest docker rmi [imageId]/[redis]:[version] 容器命令
docker ps // 查看运行的容器docker ps -a // 查看所有的容器docker -run -it[d] --name=[name] /bin/sh // 运行docker -i持续运行 -t分配终端（交互式） -d后台运行（守护式） /bin/sh mac defaultdocker exec [name] /bin/sh // 进入某一运行的容器中docer [start][stop][rm][inspect] [container-name] // 启动、停止、移除、查看详情数据卷容器</description>
    </item>
    
    <item>
      <title>#10 Go 导包（Import）顺序</title>
      <link>https://maronghe.github.io/post/10/</link>
      <pubDate>Wed, 06 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/10/</guid>
      <description>1.包存在哪里？
​	看段代码，想必大家都知道GoPath和GoRoot的是什么了。（GoPath = 你的工作空间路径 ，GoRoot = Go的安装路径）
import ( . &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func init() { Printf(&amp;#34;Go Root %s \n&amp;#34;, os.Getenv(&amp;#34;GOROOT&amp;#34;)) // Go Root /usr/local/Cellar/go/1.14/libexec  Printf(&amp;#34;Go Path %s \n&amp;#34;, os.Getenv(&amp;#34;GOPATH&amp;#34;)) // Go Path /Users/logan/go } 通过 . 对 &amp;ldquo;fmt&amp;rdquo; 进行别名，则不需要使用 fmt.Printf(&amp;quot;...&amp;quot;)了，但一个包中只能有一个.别名否则会报错。同时可以配置多个GoPath用 : 分割，例如 GOPATH=/Users/logan/go:~/myworkspace
2.扫描包的顺序？
import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) 如果搜索net/http包时，搜索顺序如下:
/usr/local/Cellar/go/1.14/libexec/src/net/http /Users/logan/go/src/net/http ~/myworkspace/src/net/http 3.包的导入顺序？及var、const、init()加载顺序。
包导入顺序如图所示，同时可知先初始化const、其次为var、之后为init()，注意同时可以有多个init方法，从上到下依次执行。
4.包重名了怎么办？
import ( &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; strings2 &amp;#34;strings&amp;#34; &amp;#34;testing&amp;#34; ) func TestImport(t *testing.T){ strings.</description>
    </item>
    
    <item>
      <title>#9 Session与Cookie的区别</title>
      <link>https://maronghe.github.io/post/9/</link>
      <pubDate>Sat, 02 May 2020 15:48:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/9/</guid>
      <description>Session 和 Cookie 看法
 首先HTTP协议是无状态的，当我们开发的一些对状态有要求的接口时，Cookie和Session弥补了这一块的能力。
Cookie
  对于HTTP协议来说，Cookie只是请求头中的一个字段且与其他字段没什么区别。
  浏览器对Cookie做了默认的支持并限制了Cookie的[同源策略]，即同域才能访问Cookie的内容。
如当我们做SSO（单点登录），一般可以把Cookie种在可访问的一级域名下。
  Session
  Session是服务器为每个Web用户分配的独立状态存储空间。
若用户的数据存放在存在某个单点服务器上时，当以七层或四层转发时，请求到后端集群的时候，就存在Session命中的问题（分布式Session问题），这时候需要有中心的方式去统一管理Session，比如存储在DB或缓存中。
  SessionID：可以由标准OAuth 2.0 来实现最终换取 token 即 sessionId ，并持有过期时间自动刷新逻辑。
  总结：
​	Cookie 和 Session 都是辅助HTTP协议无状态性产生的。</description>
    </item>
    
    <item>
      <title>#8 Study Recording</title>
      <link>https://maronghe.github.io/post/8/</link>
      <pubDate>Tue, 28 Apr 2020 22:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/8/</guid>
      <description>Q : 怎样知道一个变量分配到堆上还是栈上？
A :编译器首先尝试分配到栈上，但如果编译器不能保证函数返回值是否被引用，那么编译器会分配到堆上。如果一个对象太大了。也会分配到GC堆上。当今的编译器来说，如果一个使用变量的地址，该对象时分配堆上的候选对象，但是逃逸分析后可以识别如果改对象未超过函数的返回范围，那么该变量也可能保存在栈上
R : https://golang.org/doc/faq#stack_or_heap
  new 和 make 有什么区别
A : new(T)： 分配内存 但初始化仅为0值并返回其指针T和*T（值）。
​	new(File) =&amp;gt; &amp;amp;File{} // 初始化0值
​	make(T,args) 仅用于创建 map slice channel，并返回非0值（not zeroed）的类型T（非 *T）
R : https://golang.org/doc/effective_go.html#allocation_new
​	https://golang.org/doc/effective_go.html#allocation_make
  Go 的内存分配器是基于TCMalloc的一种分配器（TC Malloc Thread-Cached Malloc）
​	YouTube Link, GopherCon UK 2018
 申请内存顺序    4.Go是一种基于epoll的多路复用IO模型，其TCPListener是对netFD进行封装。
 Sudog的资源池：每个P都有自己的缓冲池和全局调度器缓存池。
 当本地的sudog的缓冲区为0时，加锁去全局调度器sudog的缓冲池去取全局的一半。 否则新创建一个sudog。    go语言编译后成汇编语言。
go tool compile -S file.</description>
    </item>
    
    <item>
      <title>#2 [采坑指南] json.Unmarshal后interface{}成map[string]interface{}</title>
      <link>https://maronghe.github.io/post/2/</link>
      <pubDate>Sun, 29 Mar 2020 23:43:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/2/</guid>
      <description>​	可能大家工作中都会遇到类型断言，即接口类型断言是否为某种strcut类型i.(A)或某种struct的指针类型i.(*A)。
那么当一个想要一个interface{}类型既想转换成多种类型，且多种类型并不属于同一种。这句话说的可能比较绕圈，下面举个例子来看下。
当有两个SA和SB，当我们想要从字符串翻转成结构体时。我们可以
没问题，输出结果是
sa {logan 18 Beijing} PASS 但是当结构体内容时由其他结构体，以interface{}类型进行返回时，那么情景可能如下。
如果50和51行都注释掉了的话，那么结果会输出
it2 data type is map[string]interface {} ti3 type assertion error, it isn&#39;t type SA ti4 type assertion error, it isn&#39;t type SB ti5 is map[addr:Beijing age:18 name:logan] PASS 意味着data转换成了map[string]interface{}如果转换成map[string]interface{}类型后，那么想要key中的value还需要继续类型断言。
为什么会转成map[string]interface{}呢？因为对象底层类型，当unmarshal时并不知道对象底层类型。
那么，是否有一种希望转成的类型当我们的确希望转换成某种类型，如SA或SB。
答案是需要告诉结构类型的底层类型是什么，才可做此类型的类型断言。
解开注释50或51行后，则输出结果成为
it2 data type is *main.SB ti3 type assertion error, it isn&#39;t type SA ti4 is &amp;amp;{logan 18 } ti5 type assertion error, it isn&#39;t type map[string]interface{} PASS 总结：当我们希望类型断言的结构体中是一个interface{}类型时，希望转换成某种我们希望的类型，要进行底层类型的转换。那么就要给Data进行赋值类型。则断言方可成功。</description>
    </item>
    
    <item>
      <title>#1 第一篇博客 &amp; 回顾我的大学</title>
      <link>https://maronghe.github.io/post/1/</link>
      <pubDate>Sun, 22 Mar 2020 15:48:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/1/</guid>
      <description>​	2020年3月21日晚，参加了Go夜读两周年的回顾。也是第82期的Go夜读share。虽然加入这个大家庭才不长时间，学习Golang这门语言也不是很久，因为之前做Java相关的工作。后期因为组织架构调整，公司要用Go去重写Java的服务，正因为如此，好些人都去转Go或离职。我也踏上了学习Golang的旅程。
 自述大学
 ​	我的大学专业是IOT，也就是物联网工程，一个软硬件都需要掌握的一个专业，我也相信是未来的趋势。但我从事了软件开发行业，也不知道算不算上所谓的”科班出身“。
​	大学大一度过的很”轻松加愉快“，仅参加了学校的《舞蹈社》（很奇怪，为什么一个Coder会参加舞蹈社，这可能与上高中之前的认知比较少有关吧，暂不讨论）。相反学习Software的知识比较少。
​	大二的我知道毕业时不能以在大学玩得好才能找到一份好工作的。后来经过我的DB老师的指导，自学了Java、JSP，记得当时大二的寒假，跟着老师去图书馆借了一本JSP相关的书籍，回家“啃”了起来。殊不知对于一个高中贪玩，大学以为“解放”了自己的我来说，啃书是多么的痛苦。正如我所料，我的进度比较慢，相当于把一本书分了40多份，每份是一天的消化的量。看完即完成了任务。这也是我自学之路的一个开始，但如今的我深知，如果自学都学不会的话，也不适合做Coder相关的工作。下学习又学了Java，DB等，但是看起来都只是学了个表面。
​	大三跟着老师做了个项目，名为《在线考试系统》，可想而知，在线考试系统即为学校教师出题，学生答题等一系列的相关的操作。这个项目做起来，很多的是在写业务，写逻辑。对于Spring原理来讲根本就没去了解。当时只记得一句话，‘在出校门的时候，自己有项目经历和没有项目经历完全是不一样的’。所以，乐此不疲的把这个项目做来做去。最终主要的功能也都做完了。相反，自己的DB底层原理，数据结构及算法和框架原理性的知识都被忽略了。后期才知道，毕业的春招和秋招对于应届生来讲，就考的是算法和数据结构和一些底层的原理知识。那么我一年多都是白干了么？不会吧？可能吧。不后悔不怪罪，这也是一个人渐渐成熟的体现吧。
​	大四有的同学继续考研，有的去找工作。我就是陷入了找工作的道路上。记得面试了20天左右。一个offer都没有收到，也正是我在家里的时候，IBM人力资源部给我打电话邀请我参加面试。我遍立刻答应了。一想IBM是外企大厂，以后说出去也有面子（当时无知的我）。可惜只是一个边缘部门吧。没学到什么知识，只了解的外企的文化（不加班就是个最大的特点）。所以，我觉得不能无为了，遍自学起了Java原理、设计模式、DB底层结构、Hadoop（HDFS、MapReduce）等。每日坚持9点去上班，23点才下班让的决心（当时我正式上班时间为下午2点到晚上11点，也腾出很多自学的时间）。后来请假去北京面试一周，最后也是来到了现在的公司，工作至今。
 未来的展望和建议
 ​	最后，想说这路上自己的认知发生的不断的变化。眼光看的也越来越长远了起来。想建议未来的我和其他的人，要把眼光放长远了。自己的路只能自己走，不要想着依赖谁，不要做“拿来党”，每个人都是时间都是有限的，不要辜负年轻时的自己。趁着年轻，多折腾折腾。
2020-03-22 18:07:13 于北京 马荣贺 Logan Ma</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://maronghe.github.io/post/aboutme/</link>
      <pubDate>Thu, 19 Mar 2020 21:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/aboutme/</guid>
      <description> 自我介绍
 ​	莫愁前方无知己，天下谁人不识君。
​	面试官您好，我叫马荣贺，毕业于&amp;hellip;&amp;hellip;..，目前就职于蓝信移动有限公司，从事服务端研发相关的工作。工作日常负责项目的评审、研发及后期的维护。
​	学习就要有节奏，有方向的进行。给自己顶一个短期计划，如三天，一周，半个月等。不能为了面试而学习这样只会让自己在临近工作做不下去，或想找工作之气临时抱佛脚。游戏切记成瘾！
​	学习是要有自我分析理解的过程，看网上的某些教程视频，人家仅会给你他理解到的内容，可能会有些不准确，也可能会有些偏差，当他给你讲述的同时，你可能理解有偏差。这样的话，你与其他人交流时，由于没有自己分析和摸索知识的过程，会显得格外的“虚”，不懂原理，不知其所以然。
​	所以学习还是要通过自己的一点一滴积累，寻求权威的认证，最不断地求知精神。同样在生活中多应该问问自己：“为什么？”，为什么这样做就可以，多思考，多探索。学习后要有些输出如博客等。也可以与组内和朋友交流，如果你能给其他人以通俗易懂的方式讲明白了。那么就证明你明白了。
​	分析问题的过程：
  为什么这么做？
  解决了哪些问题？
  逻辑和技术难点？
  自己做出了哪些事情？
如：『原因』系统为了解决用户的客户端APP连接会话不在线，同样可以将消息发送到对方手机上。「解决方案」从而引入了手机厂商的Push服务，可在用户登录时，端上调用手机厂商提供的结构，创建自己的手机的设备Token，将Token上传到自己的Server去维护。则服务端在发消息的同时可确定是否要发送系统Push来通知用户客户端。「性能提升」通过Push的接口的性能测试，可判别出Push服务的性能，从而发现性能瓶颈，解决和优化。
   计算机组成原理 操作系统 数据结构与算法 计算机网络（） 数据库原理 Go语言实现原理及新特性 Docker、K8S容器化、Service Mesh Redis、Kafka、ZK、ES、Nginx、Kibana、jenkins中间件 分布式、RPC、微服务链路追踪 网络安全攻击 性能测试 自定义协议  </description>
    </item>
    
  </channel>
</rss>