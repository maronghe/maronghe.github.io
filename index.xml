<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Loganma&#39;s Blog</title>
    <link>https://maronghe.github.io/</link>
    <description>Recent content on Loganma&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 15 Jun 2020 23:52:41 +0800</lastBuildDate>
    
	<atom:link href="https://maronghe.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>#16 限流方案</title>
      <link>https://maronghe.github.io/post/%E9%99%90%E6%B5%81/</link>
      <pubDate>Mon, 15 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/%E9%99%90%E6%B5%81/</guid>
      <description>限流 定时清除 （1分钟一清除） 实现简单 对于边界值，如59秒和下一秒会有问题，会得到一个请求限制速率的2倍 滑动窗口（10秒一清除） 是定时清除的一个优化，缩小了清除粒度但是还是有问题。 漏桶算法 （桶容量 + 桶流速度） https://github.com/uber-go/ratelimit ​ - 超过桶的容量就要涉及到排队或拒绝了 不支持小流量激增 令牌桶算法（定时放</description>
    </item>
    
    <item>
      <title>#15 数组和切片</title>
      <link>https://maronghe.github.io/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</link>
      <pubDate>Sun, 07 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</guid>
      <description>数组和切片的区别 底层结构 创建 var make []int{} slice扩容 复用底层数组 注意： array不能跟nil比较，编译报错 make只能用于 map， channel ，slice的创建，不能创建数组 var arr [5]int 创建数组，初始化为5个零 ​ 数组大小不可变，切片可变 kind 数组 array [2]int , [3]int[] slice slice []int copy 仅能用于slice，并且dst必须要有容量</description>
    </item>
    
    <item>
      <title>#14 defer different</title>
      <link>https://maronghe.github.io/post/Defer-1.12-vs-1.13-vs-1.14/</link>
      <pubDate>Mon, 01 Jun 2020 23:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/Defer-1.12-vs-1.13-vs-1.14/</guid>
      <description>Defer 1.12 vs 1.13 vs 1.14 1.12之前 defer func(){} —&amp;gt; 会被翻译成两个函数 deferproc() : 注册，defer func(){} 到g的defer链表中，头插法。defer需要进行堆分配，而且参数变量需要进行堆栈间拷贝。 runtime.deferreturn() : 执行，defer链表的中的每一项 （先注册 -》 后执行） 1 2 3 4 5 6 7 // runtime/runtime2.go type g struct { ... _panic *_panic _defer *_defer // defer 链表 ... } 步骤解析</description>
    </item>
    
    <item>
      <title>#13 TCP &amp; UDP</title>
      <link>https://maronghe.github.io/post/13/</link>
      <pubDate>Fri, 29 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/13/</guid>
      <description>TCP TCP三次握手机制，为什么要三次握手？ 考点： 为什么要握手？ TCP最重要的特性就是可靠性，自己发出去的数据要等到对方去确认，并回复收到了（ack），TCP是支持双工协议，所以双方都要去维护自己的序列号（seq，不从0开始，随机生成的）。因为要获取序列号（和MSS，滑动窗口），所以</description>
    </item>
    
    <item>
      <title>#12 二叉搜索树（BST）In Go</title>
      <link>https://maronghe.github.io/post/12/</link>
      <pubDate>Tue, 19 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/12/</guid>
      <description>二叉搜索树（Binary Search Tree In Go） ​ 二搜索树叉树特点： 极端情况下会退化成链表。 中序遍历是递增的。 父节点的左孩子都小于父节点，又孩子都大于父节点 时间复杂度： Talk is cheap, show me the code 源码：https://github.com/maronghe/basego/blob/master/ds/bi</description>
    </item>
    
    <item>
      <title>#11 Docker In Hour</title>
      <link>https://maronghe.github.io/post/11/</link>
      <pubDate>Sun, 17 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/11/</guid>
      <description>Docker 一个统一环境dev/qa/app/beta/cloud的容器、容器是相互隔离的。 Docker是容器技术，解决软件跨环境的迁移的问题。 Docker安装后，在本地一守护进程(Daemon)的方式后台运行。 -&amp;gt; docker -v Docker version 19.03.8, build afacb8b 本地部署的分为image和container，image相当于</description>
    </item>
    
    <item>
      <title>#10 Go 导包（Import）顺序</title>
      <link>https://maronghe.github.io/post/10/</link>
      <pubDate>Wed, 06 May 2020 16:08:53 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/10/</guid>
      <description>1.包存在哪里？ ​ 看段代码，想必大家都知道GoPath和GoRoot的是什么了。（GoPath = 你的工作空间路径 ，GoRoot = Go的安装路径） 1 2 3 4 5 6 7 8 import ( . &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func init() { Printf(&amp;#34;Go Root %s \n&amp;#34;, os.Getenv(&amp;#34;GOROOT&amp;#34;)) // Go Root /usr/local/Cellar/go/1.14/libexec Printf(&amp;#34;Go Path %s \n&amp;#34;, os.Getenv(&amp;#34;GOPATH&amp;#34;)) // Go Path /Users/logan/go } 通过 . 对 &amp;ldquo;fmt&amp;rdquo; 进行别名，则不需要使用 fmt.Printf(&amp;quot</description>
    </item>
    
    <item>
      <title>#9 Session与Cookie的区别</title>
      <link>https://maronghe.github.io/post/9/</link>
      <pubDate>Sat, 02 May 2020 15:48:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/9/</guid>
      <description>Session 和 Cookie 看法 首先HTTP协议是无状态的，当我们开发的一些对状态有要求的接口时，Cookie和Session弥补了这一块的能力。 Cookie 对于HTTP协议来说，Cookie只是请求头中的一个字段且与其他字段没什么区别。 浏览器对Cookie做了默认的支持并限制了Cookie的[同源策略]，即同</description>
    </item>
    
    <item>
      <title>#8 Study Recording</title>
      <link>https://maronghe.github.io/post/8/</link>
      <pubDate>Tue, 28 Apr 2020 22:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/8/</guid>
      <description>Q : 怎样知道一个变量分配到堆上还是栈上？ A :编译器首先尝试分配到栈上，但如果编译器不能保证函数返回值是否被引用，那么编译器会分配到堆上。如果一个对象太大了。也会分配到GC堆上。当今的编译器来说，如果一个使用变量的地址，该对象时分配堆上的候选对象，但是逃逸分析后可以识别如果改对象未</description>
    </item>
    
    <item>
      <title>#7 Goalng协程和线程</title>
      <link>https://maronghe.github.io/post/7/</link>
      <pubDate>Tue, 21 Apr 2020 16:38:02 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/7/</guid>
      <description>协程和线程： os线程：每几毫秒，硬件计时器会中断处理器，然后调用schedule的内核函数，挂起当前执行的线程，将状态保存到寄存器中。检查可执行线程列表并决定下一次运行的线程。并从内存中恢复寄存器信息继续执行。因为os线程是被内核锁调度，所以一个线程执行状态切换到另一个线程的执行</description>
    </item>
    
    <item>
      <title>#6 Golang锁</title>
      <link>https://maronghe.github.io/post/6/</link>
      <pubDate>Wed, 15 Apr 2020 16:38:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/6/</guid>
      <description>Golang锁 RWMutex 读写锁： ​ 内部需要维护一个复杂的内部记录。所以适用于并发读取，修改操作比较少的情况，相反，竞争较低相较于互斥锁性能较慢。 ​ Mutex 互斥锁：不可重入 ​ 不可重入的原因：互斥量的目的是为了确保共享变量在程序执行时的关键点上能够保证不变性。不变性的其中之一是“没有gorouti</description>
    </item>
    
    <item>
      <title>#5 GC</title>
      <link>https://maronghe.github.io/post/5/</link>
      <pubDate>Fri, 10 Apr 2020 16:38:02 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/5/</guid>
      <description>GC分类：追踪式、引用计数式 追踪式，分为多种不同类型，例如： 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而</description>
    </item>
    
    <item>
      <title>#4 最终一致性</title>
      <link>https://maronghe.github.io/post/4/</link>
      <pubDate>Sun, 05 Apr 2020 16:38:02 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/4/</guid>
      <description>最终一致性的讨论： ​ 在如今的分布式微服务架构下的系统中，各服务之间都会存在直接或间接的调用。很难免很多的方法调用的方法失败，或因为网络波动等处理不成功。 集中方案，及其优缺点： 方案 优点 不足 saga pattern（个人理解和TCC差不多）：即当发生失败处理是需要调用回滚函数。 可以按照不同的</description>
    </item>
    
    <item>
      <title>#3 Do A Contributor For Go</title>
      <link>https://maronghe.github.io/post/3/</link>
      <pubDate>Tue, 31 Mar 2020 22:05:22 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/3/</guid>
      <description>​ 激动的心，颤抖的手。 ​ &amp;mdash; 记录了我成为一名Go Contributor 的过程 趁着这个热乎劲，记录一下美好的生活。 ​ 非常开心也非常荣幸的正在成为Go的贡献者之一。这可能也是村子走出来的孩子不太懂得世面的第一步吧。 ​ 2020年03月31日上午正在看着Go Map实现原理时，突然发现Go doc中有一个参数写错</description>
    </item>
    
    <item>
      <title>#2 [采坑指南] json.Unmarshal后interface{}成map[string]interface{}</title>
      <link>https://maronghe.github.io/post/2/</link>
      <pubDate>Sun, 29 Mar 2020 23:43:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/2/</guid>
      <description>​ 可能大家工作中都会遇到类型断言，即接口类型断言是否为某种strcut类型i.(A)或某种struct的指针类型i.(*A)。 那么当一个想要一个interface{}类型既想转换成多种类型，且多种类型并不属于同一种。这句话说的可能比较绕圈，下面举个例子来看下。 当有两个SA和SB，</description>
    </item>
    
    <item>
      <title>#1 第一篇博客 &amp; 回顾我的大学</title>
      <link>https://maronghe.github.io/post/1/</link>
      <pubDate>Sun, 22 Mar 2020 15:48:01 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/1/</guid>
      <description>​ 2020年3月21日晚，参加了Go夜读两周年的回顾。也是第82期的Go夜读share。虽然加入这个大家庭才不长时间，学习Golang这门语言也不是很久，因为之前做Java相关的工作。后期因为组织架构调整，公司要用Go去重写Java的服务，正因为如此，好些人都去转Go或离职。我也</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://maronghe.github.io/post/AboutMe/</link>
      <pubDate>Thu, 19 Mar 2020 21:52:41 +0800</pubDate>
      
      <guid>https://maronghe.github.io/post/AboutMe/</guid>
      <description>自我介绍 ​ 莫愁前方无知己，天下谁人不识君。 ​ 面试官您好，我叫马荣贺，毕业于&amp;hellip;&amp;hellip;..，目前就职于蓝信移动有限公司，从事服务端研发相关的工作。工作日常负责项目的评审、研发及后期的维护。 ​ 学习就要有节奏，有方向的进行。给自己顶一个短期计划，如三天，一周，半个</description>
    </item>
    
  </channel>
</rss>