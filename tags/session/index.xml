<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>session on 马荣贺&#39;s Home, You are my Homie!</title>
    <link>https://maronghe.github.io/tags/session/</link>
    <description>Recent content in session on 马荣贺&#39;s Home, You are my Homie!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 May 2020 18:36:00 +0200</lastBuildDate><atom:link href="https://maronghe.github.io/tags/session/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>#10 Session and Cookie</title>
      <link>https://maronghe.github.io/2020/10.sessionandcookie/</link>
      <pubDate>Sat, 02 May 2020 18:36:00 +0200</pubDate>
      
      <guid>https://maronghe.github.io/2020/10.sessionandcookie/</guid>
      <description>Session 和 Cookie 看法 首先HTTP协议是无状态的，当我们开发的一些对状态有要求的接口时，Cookie和Session弥补了这一块的能力。
Cookie   对于HTTP协议来说，Cookie只是请求头中的一个字段且与其他字段没什么区别。
  浏览器对Cookie做了默认的支持并限制了Cookie的[同源策略]，即同域才能访问Cookie的内容。
如当我们做SSO（单点登录），一般可以把Cookie种在可访问的一级域名下。
  Session   Session是服务器为每个Web用户分配的独立状态存储空间。
若用户的数据存放在存在某个单点服务器上时，当以七层或四层转发时，请求到后端集群的时候，就存在Session命中的问题（分布式Session问题），这时候需要有中心的方式去统一管理Session，比如存储在DB或缓存中。
  SessionID：可以由标准OAuth 2.0 来实现最终换取token即 sessionId ，并持有过期时间自动刷新逻辑。
  总结： Cookie 和 Session 都是辅助HTTP协议无状态性产生的。</description>
    </item>
    
  </channel>
</rss>
