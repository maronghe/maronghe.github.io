<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>栈 on 马荣贺&#39;s Home, You are my Homie!</title>
    <link>https://maronghe.github.io/tags/%E6%A0%88/</link>
    <description>Recent content in 栈 on 马荣贺&#39;s Home, You are my Homie!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Apr 2020 18:36:00 +0200</lastBuildDate><atom:link href="https://maronghe.github.io/tags/%E6%A0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>#8 Study Recording</title>
      <link>https://maronghe.github.io/2020/8.studyrecording/</link>
      <pubDate>Tue, 28 Apr 2020 18:36:00 +0200</pubDate>
      
      <guid>https://maronghe.github.io/2020/8.studyrecording/</guid>
      <description>Q : 怎样知道一个变量分配到堆上还是栈上？
A :编译器首先尝试分配到栈上，但如果编译器不能保证函数返回值是否被引用，那么编译器会分配到堆上。如果一个对象太大了。也会分配到GC堆上。当今的编译器来说，如果一个使用变量的地址，该对象时分配堆上的候选对象，但是逃逸分析后可以识别如果改对象未超过函数的返回范围，那么该变量也可能保存在栈上。
R : https://golang.org/doc/faq#stack_or_heap
  new 和 make 有什么区别
A : new(T)： 分配内存 但初始化仅为0值并返回其指针T和*T（值）。
new(File) =&amp;gt; &amp;amp;File{} // 初始化0值
make(T,args) 仅用于创建 map slice channel，并返回非0值（not zeroed）的类型T（非 *T）
R : https://golang.org/doc/effective_go.html#allocation_new
https://golang.org/doc/effective_go.html#allocation_make
  Go 的内存分配器是基于TCMalloc的一种分配器（TC Malloc Thread-Cached Malloc）
YouTube Link, GopherCon UK 2018
 申请内存顺序    4.Go是一种基于epoll的多路复用IO模型，其TCPListener是对netFD进行封装。
  Sudog的资源池：每个P都有自己的缓冲池和全局调度器缓存池。
 当本地的sudog的缓冲区为0时，加锁去全局调度器sudog的缓冲池去取全局的一半。 否则新创建一个sudog。    go语言编译后成汇编语言。
go tool compile -S file.go</description>
    </item>
    
  </channel>
</rss>
