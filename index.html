<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.69.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>老干妈</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://maronghe.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://maronghe.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://maronghe.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://maronghe.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://maronghe.github.io/index.xml" rel="alternate" type="application/rss+xml" title="老干妈" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://maronghe.github.io/"><h1>老干妈</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://maronghe.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/%E9%99%90%E6%B5%81/">#16 限流方案</a>
  </h1>
  <time datetime="2020-06-15T23:52:41&#43;0800" class="post-date">Mon, Jun 15, 2020</time>
  限流
   定时清除 （1分钟一清除）
 实现简单 对于边界值，如59秒和下一秒会有问题，会得到一个请求限制速率的2倍    滑动窗口（10秒一清除）
 是定时清除的一个优化，缩小了清除粒度但是还是有问题。    漏桶算法 （桶容量 + 桶流速度） https://github.com/uber-go/ratelimit
​	- 超过桶的容量就要涉及到排队或拒绝了
 不支持小流量激增    令牌桶算法（定时放入桶中令牌） https://github.com/juju/ratelimit
 支持小流量并发激增    分布式限流则可用于 Redis + Lua脚本实现，其原理几乎差不多。
local key = &#34;rate.limit:&#34; .. KEYS[1] --限流KEY local limit = tonumber(ARGV[1]) --限流大小 local current = tonumber(redis.call(&#39;get&#39;, key) or &#34;0&#34;) if current + 1 &gt; limit then --如果超出限流大小 return 0 else --请求数+1，并设置1秒过期 redis.
  
  <div class="read-more-link">
    <a href="/post/%E9%99%90%E6%B5%81/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">#15 数组和切片</a>
  </h1>
  <time datetime="2020-06-07T23:52:41&#43;0800" class="post-date">Sun, Jun 7, 2020</time>
  数组和切片的区别
  底层结构 创建  var make []int{}   slice扩容 复用底层数组  注意：
 array不能跟nil比较，编译报错 make只能用于 map， channel ，slice的创建，不能创建数组 var arr [5]int 创建数组，初始化为5个零  ​
 数组大小不可变，切片可变 kind 数组 array [2]int , [3]int[] slice slice []int copy 仅能用于slice，并且dst必须要有容量 复用底部数组 t3 := t1[2:4] // 左闭右开 创建  var arr []int // arr == nil true make &amp; []int{} // arr != nil true    arr := [2]int{1, 3} fmt.
  
  <div class="read-more-link">
    <a href="/post/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/defer-1.12-vs-1.13-vs-1.14/">#14 defer different</a>
  </h1>
  <time datetime="2020-06-01T23:52:41&#43;0800" class="post-date">Mon, Jun 1, 2020</time>
  Defer 1.12 vs 1.13 vs 1.14
 1.12之前 defer func(){} —&gt; 会被翻译成两个函数
  deferproc() : 注册，defer func(){} 到g的defer链表中，头插法。defer需要进行堆分配，而且参数变量需要进行堆栈间拷贝。
  runtime.deferreturn() : 执行，defer链表的中的每一项
（先注册 -》 后执行）
// runtime/runtime2.go type g struct { ... _panic *_panic _defer *_defer // defer 链表  ... }   步骤解析：
deferproc
 从defer pool预分配不同规格的defer，不满足时再创建，用完再放回池中。 进行堆分配_defer结构体，将参数拷贝到堆上 连接到g的defer链表上  runtime.deferreturn
 执行defer注册的funcval，将堆上的参数拷贝到栈上，进行执行。  注意：
 若其中有发现闭包，堆上分配捕获变量的地址，执行时通过指针加偏移量找到被捕获的变量进行操作 形如defer A(B(a))  函数A需要依赖B的返回值进行堆分配内存大小 所以B函数在注册时候执行，传入变量啊    存在问题：（慢!
  
  <div class="read-more-link">
    <a href="/post/defer-1.12-vs-1.13-vs-1.14/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/13/">#13 TCP &amp; UDP</a>
  </h1>
  <time datetime="2020-05-29T16:08:53&#43;0800" class="post-date">Fri, May 29, 2020</time>
  TCP
   TCP三次握手机制，为什么要三次握手？
考点：
  为什么要握手？
TCP最重要的特性就是可靠性，自己发出去的数据要等到对方去确认，并回复收到了（ack），TCP是支持双工协议，所以双方都要去维护自己的序列号（seq，不从0开始，随机生成的）。因为要获取序列号（和MSS，滑动窗口），所以要握手。
  为什么要三次？
因为关闭连接的时候，TCP协议允许连接处于半打开（半关闭）状态。而建立连接不允许连接处于半打开状态，所以Server要把自己的序列号回复过来。
    HTTP 缓存处理流程？
Request 中 Cache-Control: max-age=30 ，告诉代理服务器，如果有缓存的话，如果超过30秒时，就不要给Client返回，让代理服务器去原服务器去取。
Response 中的 Cache-Control: max-age=30 ，告诉客户端，只能到30秒，否则将视为过期。
  地址栏输入URL到底发生了什么?
考点：
  应用层
DNS域名解析-》代理服务器 -》可能缓存-&gt;网关（Nginx、Apache）-》Origin Server 【如上图所示】
  请求编码
http://[domain]/[path] -&gt; 转换成 Method ，Path ，Version Protocol，Header等
  网络分层
 TCP解决进程到进程之间的通信 IP 解决主机到主机之间的通信 数据链路层 解决 局域网内部的通信      HTTP长链接有哪些优点？
考点：
1.长链接和短连接的区分？
  
  <div class="read-more-link">
    <a href="/post/13/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/12/">#12 二叉搜索树（BST）In Go</a>
  </h1>
  <time datetime="2020-05-19T16:08:53&#43;0800" class="post-date">Tue, May 19, 2020</time>
  二叉搜索树（Binary Search Tree In Go）
 ​	二搜索树叉树特点：
  极端情况下会退化成链表。
  中序遍历是递增的。
  父节点的左孩子都小于父节点，又孩子都大于父节点
  时间复杂度：
  Talk is cheap, show me the code
源码：https://github.com/maronghe/basego/blob/master/ds/binary_search_tree.go
binary_search_tree.go
/* * Copyright (c) 2020 RongHe Ma. * Recording from daily work flow. */ package ds import ( &#34;fmt&#34; ) // BST Node type Node struct { data int count int left *Node right *Node } func NewBinarySearchTree(data int) *Node { return &amp;Node{data, 1, nil, nil} } func (node *Node)Insert(data int) *Node { return _insert(node,data) } func _insert(root *Node, data int) *Node{ if root == nil { return NewBinarySearchTree(data) } if root.
  
  <div class="read-more-link">
    <a href="/post/12/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/11/">#11 Docker In Hour</a>
  </h1>
  <time datetime="2020-05-17T16:08:53&#43;0800" class="post-date">Sun, May 17, 2020</time>
  Docker
 一个统一环境dev/qa/app/beta/cloud的容器、容器是相互隔离的。
Docker是容器技术，解决软件跨环境的迁移的问题。
Docker安装后，在本地一守护进程(Daemon)的方式后台运行。
-&gt; docker -v Docker version 19.03.8, build afacb8b 本地部署的分为image和container，image相当于类，container相当于对象，一个类可以创建多个对象。
image 可来自于docker官方Repository Docker Hub 和 private Repository或阿里云镜像 TODO
镜像命令
docker images // 查看当前已安装的镜像列表 docker search [redis] // 搜索redis镜像 docker pull [redis]:[version] // 不指定version默认下载latest docker rmi [imageId]/[redis]:[version] 容器命令
docker ps // 查看运行的容器docker ps -a // 查看所有的容器docker -run -it[d] --name=[name] /bin/sh // 运行docker -i持续运行 -t分配终端（交互式） -d后台运行（守护式） /bin/sh mac defaultdocker exec [name] /bin/sh // 进入某一运行的容器中docer [start][stop][rm][inspect] [container-name] // 启动、停止、移除、查看详情数据卷容器
  
  <div class="read-more-link">
    <a href="/post/11/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/10/">#10 Go 导包（Import）顺序</a>
  </h1>
  <time datetime="2020-05-06T16:08:53&#43;0800" class="post-date">Wed, May 6, 2020</time>
  1.包存在哪里？
​	看段代码，想必大家都知道GoPath和GoRoot的是什么了。（GoPath = 你的工作空间路径 ，GoRoot = Go的安装路径）
import ( . &#34;fmt&#34; &#34;os&#34; ) func init() { Printf(&#34;Go Root %s \n&#34;, os.Getenv(&#34;GOROOT&#34;)) // Go Root /usr/local/Cellar/go/1.14/libexec  Printf(&#34;Go Path %s \n&#34;, os.Getenv(&#34;GOPATH&#34;)) // Go Path /Users/logan/go } 通过 . 对 &ldquo;fmt&rdquo; 进行别名，则不需要使用 fmt.Printf(&quot;...&quot;)了，但一个包中只能有一个.别名否则会报错。同时可以配置多个GoPath用 : 分割，例如 GOPATH=/Users/logan/go:~/myworkspace
2.扫描包的顺序？
import ( &#34;fmt&#34; &#34;net/http&#34; ) 如果搜索net/http包时，搜索顺序如下:
/usr/local/Cellar/go/1.14/libexec/src/net/http /Users/logan/go/src/net/http ~/myworkspace/src/net/http 3.包的导入顺序？及var、const、init()加载顺序。
包导入顺序如图所示，同时可知先初始化const、其次为var、之后为init()，注意同时可以有多个init方法，从上到下依次执行。
4.包重名了怎么办？
import ( &#34;runtime&#34; &#34;strings&#34; strings2 &#34;strings&#34; &#34;testing&#34; ) func TestImport(t *testing.T){ strings.
  
  <div class="read-more-link">
    <a href="/post/10/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/9/">#9 Session与Cookie的区别</a>
  </h1>
  <time datetime="2020-05-02T15:48:01&#43;0800" class="post-date">Sat, May 2, 2020</time>
  Session 和 Cookie 看法
 首先HTTP协议是无状态的，当我们开发的一些对状态有要求的接口时，Cookie和Session弥补了这一块的能力。
Cookie
  对于HTTP协议来说，Cookie只是请求头中的一个字段且与其他字段没什么区别。
  浏览器对Cookie做了默认的支持并限制了Cookie的[同源策略]，即同域才能访问Cookie的内容。
如当我们做SSO（单点登录），一般可以把Cookie种在可访问的一级域名下。
  Session
  Session是服务器为每个Web用户分配的独立状态存储空间。
若用户的数据存放在存在某个单点服务器上时，当以七层或四层转发时，请求到后端集群的时候，就存在Session命中的问题（分布式Session问题），这时候需要有中心的方式去统一管理Session，比如存储在DB或缓存中。
  SessionID：可以由标准OAuth 2.0 来实现最终换取 token 即 sessionId ，并持有过期时间自动刷新逻辑。
  总结：
​	Cookie 和 Session 都是辅助HTTP协议无状态性产生的。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/8/">#8 Study Recording</a>
  </h1>
  <time datetime="2020-04-28T22:52:41&#43;0800" class="post-date">Tue, Apr 28, 2020</time>
  Q : 怎样知道一个变量分配到堆上还是栈上？
A :编译器首先尝试分配到栈上，但如果编译器不能保证函数返回值是否被引用，那么编译器会分配到堆上。如果一个对象太大了。也会分配到GC堆上。当今的编译器来说，如果一个使用变量的地址，该对象时分配堆上的候选对象，但是逃逸分析后可以识别如果改对象未超过函数的返回范围，那么该变量也可能保存在栈上
R : https://golang.org/doc/faq#stack_or_heap
  new 和 make 有什么区别
A : new(T)： 分配内存 但初始化仅为0值并返回其指针T和*T（值）。
​	new(File) =&gt; &amp;File{} // 初始化0值
​	make(T,args) 仅用于创建 map slice channel，并返回非0值（not zeroed）的类型T（非 *T）
R : https://golang.org/doc/effective_go.html#allocation_new
​	https://golang.org/doc/effective_go.html#allocation_make
  Go 的内存分配器是基于TCMalloc的一种分配器（TC Malloc Thread-Cached Malloc）
​	YouTube Link, GopherCon UK 2018
 申请内存顺序    4.Go是一种基于epoll的多路复用IO模型，其TCPListener是对netFD进行封装。
 Sudog的资源池：每个P都有自己的缓冲池和全局调度器缓存池。
 当本地的sudog的缓冲区为0时，加锁去全局调度器sudog的缓冲池去取全局的一半。 否则新创建一个sudog。    go语言编译后成汇编语言。
go tool compile -S file.
  
  <div class="read-more-link">
    <a href="/post/8/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/7/">#7 Goalng协程和线程</a>
  </h1>
  <time datetime="2020-04-21T16:38:02&#43;0800" class="post-date">Tue, Apr 21, 2020</time>
   协程和线程：
   os线程：每几毫秒，硬件计时器会中断处理器，然后调用schedule的内核函数，挂起当前执行的线程，将状态保存到寄存器中。检查可执行线程列表并决定下一次运行的线程。并从内存中恢复寄存器信息继续执行。因为os线程是被内核锁调度，所以一个线程执行状态切换到另一个线程的执行状态需要切换上下文。也就是说，存储用户线程的状态到寄存器，和回复寄存器中读取状态，更新调度器的速度是很慢的。因为其内部局限性很差，需要访问内存好几次，增加运行运行cpu的周期。
  协程调度：
 Go有自己的调度器，m:n，n个os线程上调度m个协程。调度器的工作和内核的调度是相似的，但调度器只关注go程序中的协程。 和os线程调度不同的是，go并不是一个硬件定时器，而是被go“建筑”本身进行调度的。  比如一个协程执行了time.Sleep()或channel调用或mutex操作阻塞时。调度器会使其进入休眠，并开始执行另一个协程，直到时机到了再去唤醒第一个协程。因为这种调度不需要进入内核的上下文。所以重新调度一个协程要比调度一个线程的代价要低得多。      区别：
 线程是由系统操作系统（os）进行调度的，需要上下文切换 协程一般是由开发者显式调度，避免了上下文切换，从而简化了高并发。[Go并发的实现原理]    传统是多线程，共享内存来实现通信， 例如JAVA，CPP；而go采用CSP，通过通信方式来共享内存。
  Java中在访问共享变量（Map，List等）时需要加锁进行访问，从而也衍生出一种方便操作的数据类型，即线程安全的集合，例如java.util.concurrent.包中的数据结构。
  Go采用CSP，通信来共享内存方式
  Channel 实现原理
Go channel 实现原理分析 - golang开发笔记 - SegmentFault 思否
 数据结构，实际上是基于RingBuffer Wiki数据结构的实现  dataqsiz // 缓冲区容量，循环队列 qcount // 缓冲区的元素个数 Buf unsafe.Pointer // 指向缓冲区，表示一个已经发送但还未接收的数据。 sendx // 下一个可发送的地址 recvx // 下一个可接收的地址 sendq // 发送的sudog列表，当一个发送操作执行时，若缓冲区满了且无接收者在接送，则协程挂起，并将sudog放入sendq中 sudo G - G 代表Goroutine recvq // 接收的sudog列表，当一个接受操作执行时。若缓冲区无数据且无发送者在等待，则协程挂起，并将sudog放入recvq中 closed // 管道是否关闭 elemsize // 元素大小 elemtype // *_type 元素类型 lock mutex // 锁，用于hchan加锁, 限制只能一个goroutine同时访问一个channel   创建channel  创建channel时可以执行是否包含缓冲器。   写入数据流程  先判断recvq是否非空？Y - 取出goroutine，将值写入，唤醒G，gounpark N - 判断buf中是否有空位？ Y - 写入空位 N - 将输入方法sendq中，park G，挂起G，等待唤醒   读数据  先判断sendq中是否非空 - N 再判断 countq &gt;0 Y - 从buf中读取一个元素执行；否则将当前的goroutine加入recvq，中等待唤醒。当唤醒时，证明有数据写入。执行结束 Y - 判断是否有缓冲区 N- 从sendq中读取一个G，读取G中的数据，唤醒G，结束 Y 从缓冲区队首取出数据，然后从sendq取出数据，写入缓冲区队尾中，然后唤醒G，执行，结束。   关闭channel 会panic  关闭值为nil的channel 关闭已经关闭的channel 向已经关闭的channel 写数据   常见的用法  单向channel，仅用来发送或接收数据  func readChan(chanName &lt;-chan int) //接收数据 func writeChan(chanName chan&lt;- int) //写入数据   select  使用select 可以同时监控多个channel （多路复用） 当同时满足时，select会随机选择一个读取数据。 select的case语句读channel不会阻塞，尽管channel中没有数据。这个由于case语句编译后调用读channel时，会明确传入不阻塞的参数，此时读不到数据中石，不会将当前goroutine加入等待队列，而是直接返回。   range  一直读取channel中的数据，就像遍历slice一样。当没有数据可处理时，阻塞当前的goroutine，此时写channel的goroutine退出了，系统检测这种情况会发生panic，否则range将永久阻塞。        
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/6/">#6 Golang锁</a>
  </h1>
  <time datetime="2020-04-15T16:38:01&#43;0800" class="post-date">Wed, Apr 15, 2020</time>
  Golang锁  RWMutex 读写锁：
 ​	内部需要维护一个复杂的内部记录。所以适用于并发读取，修改操作比较少的情况，相反，竞争较低相较于互斥锁性能较慢。 ​	Mutex 互斥锁：不可重入 ​	不可重入的原因：互斥量的目的是为了确保共享变量在程序执行时的关键点上能够保证不变性。不变性的其中之一是“没有goroutine访问共享变量”。但实际上对于mutex保护的变量来说，不变性还包括其它方面。当一个goroutine获得了一个互斥锁时，它会断定这种不变性能够被保持。其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏。然而当其释放锁之后，它必须保证不变性已经恢复原样。尽管一个可以重入的mutex也可以保证没有其它的goroutine在访问共享变量，但这种方式没法保证这些变量额外的不变性。 ​	总结：互斥锁中的互斥量要保证共享变量的不变性，可重入锁可以保证没有其他的goroutine访问共享变量，但不能保证额外变量的不变性。
 Mutex锁的实现
   加锁
  解锁
   // sync.Once() TODO type Once struct { m Mutex done uint32 } func (o *Once) Do(f func()) { if atomic.LoadUint32(&amp;o.done) == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(&amp;o.done, 1) f() // 只执行一次  } } 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/5/">#5 GC</a>
  </h1>
  <time datetime="2020-04-10T16:38:02&#43;0800" class="post-date">Fri, Apr 10, 2020</time>
  GC分类：追踪式、引用计数式
  追踪式，分为多种不同类型，例如：  标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。 增量整理：在增量式的基础上，增加对对象的整理过程。 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。   引用数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。   Go中使用的GC方式
 Go使用无分代、不整理、并发的三色标记清除法（与用户代码并发执行）
Because:(反证法)
 对象整理的优势是为了解决内存碎片化的问题和顺序内存分配器。但Go采用tcmalloc，基本上是没有碎片化的对象。顺序内存分配器在多线程下不适用。基于tcmalloc的内存分配算法，对于整理发来说，并不能得到实质的提升。 分代回收基于分代假设，分代假设主要将基于回收精力放到新创建的对象上。而Go创建对象时会进行逃逸分析会把对象尽量的分配到栈上，只有长时间存活的对象才会分配到堆上。那么goroutine死亡后，栈也会直接回收，不会参与GC，那么分代回收没有优势。 go采用与用户并发执行，则STW时间与对象的大小和是否分代，并没有直接关系。go团队使用更好的回收方式（部分CPU执行垃圾回收），而不把暂停回收时间作为唯一标准。   三色标记法
  三色标记法是一种描述追踪式垃圾回收的机制的一种方式。它描述了由黑、灰和白色组成（仅为概念），从可能要删除的对象列表中（白色列表），通过_根对象_逐步着色成灰色，最终扫描完成后为黑色，当无灰色对象，其余的白色对象即可回收对象，将被删掉的过程。 根对象有哪些？  栈中的对象 全局变量 寄存器     并发标记回收方式实现的难点
 ​	难点：回收的准确性：不能漏掉可回收对象，也不能多删不可回收对象
 赋值器的颜色 及 强弱不变性
  强弱不变性
当一下两个条件均满足时，会破坏垃圾回收的正确性。（即对象分配为一个有向图）
条件1：赋值器修改对象图，导致黑对象引用白色对象。
条件2：从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。
译：
条件1：赋值器修改黑色对象引用白色对象。
条件2：赋值器破坏了未经访问的，灰色对象到白色对象的路径。
当避免条件
避免条件1：则所有白色对象均被引用，没有白色对象会被遗漏。
避免条件2：则从灰色对象出发，总存在一条没有访问过的路径，从而找到白色对象，而不会遗漏白色存活对象。
 强不变性：同时满足条件1和条件2。即没有对象会被遗漏，没有未访问的路径会被破坏。
弱不变性：满足条件1。即没有对象会被破坏。但不能保证黑色对象引用白色对象。
   赋值器分为灰色赋值器（Dijkstra插入屏障）和黑色赋值器（Yuasa 屏障）
1.赋值器的颜色对对象回收的影响
允许灰色赋值器存在
  则必须在回收结束之前重新扫描对象图。
  
  <div class="read-more-link">
    <a href="/post/5/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/4/">#4 最终一致性</a>
  </h1>
  <time datetime="2020-04-05T16:38:02&#43;0800" class="post-date">Sun, Apr 5, 2020</time>
  最终一致性的讨论：
​	在如今的分布式微服务架构下的系统中，各服务之间都会存在直接或间接的调用。很难免很多的方法调用的方法失败，或因为网络波动等处理不成功。
集中方案，及其优缺点：
   方案 优点 不足     saga pattern（个人理解和TCC差不多）：即当发生失败处理是需要调用回滚函数。 可以按照不同的业务逻辑自己西实现回滚逻辑。 1.当系统过于庞大时候，怎么可能保证所有的服务都具备回滚功能？2.回滚失败后，需要人工处理，增加人工介入系统的可能。   可靠MQ + 失败消息落盘，定时重试 + （MQ采用HTTP POST向业务方发送请求，可避免所有服务都使用MQ Client） 解耦、重试 1.生产者的业务执行和Msg发送不是原子性。所以**_需要MQ支持事务_**。2.不适用于对消息有顺序性要求的场景。**_仅试用于简单的情景_**。3.上游失败落盘、后台发送 + 下游需要处理乱序消息问题。**_不适用于消息定制的不同逻辑_**。   业务模块中插入多个“桩”，每过一段时间触发状态的全量更新。那么我就找一个其它模块来持续地刷新我系统中的数据状态。从而达到“最终一致”。 根据最终状态判断一致性。 比较反技术，性能全量同步数据需要考虑性能和同步契机。    
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/3/">#3 Do A Contributor For Go</a>
  </h1>
  <time datetime="2020-03-31T22:05:22&#43;0800" class="post-date">Tue, Mar 31, 2020</time>
  ​	激动的心，颤抖的手。
​	&mdash; 记录了我成为一名Go Contributor 的过程
 趁着这个热乎劲，记录一下美好的生活。
 ​	非常开心也非常荣幸的正在成为Go的贡献者之一。这可能也是村子走出来的孩子不太懂得世面的第一步吧。
​	2020年03月31日上午正在看着Go Map实现原理时，突然发现Go doc中有一个参数写错了。也可能是修改参数时遗漏了。所以我就小心翼翼的在Go的Github中提出了一个小小的Issue，表明我要修改的内容。若想看问题修改了是什么的话，请点击这里，因为就是一个小小的问题，也算不上是个问题的问题。所以就不罗列于此了。
​	随后我过了几个小时，有一个位Go团队的成员ALTree回复了我的Issue。并说这是一个问题。Yeah sure. Please send a change这是他的原话。
​	那么接下来就是应该提交一个CL，但是我看Code Review上面我当我去执行
git clone https://go.googlesource.com/go &amp;&amp; (cd go &amp;&amp; f=git rev-parse &ndash;git-dir/hooks/commit-msg ; mkdir -p $(dirname $f) ; curl -Lo $f https://gerrit-review.googlesource.com/tools/hooks/commit-msg ; chmod +x $f) 发生了fatal: unable to access 'https://go.googlesource.com/go/': Failed to connect to go.googlesource.com port 443: Operation timed out 操作超时。
搞了半天后，咨询了一下欧神（我的偶像），说我网络可能有问题，并且给了我成为一个Contributor的一个教程。所以按着教程，又做了下Contributor的学习。所以接下来还是应该继续处理TimeOut的问题。So I need a network helper.
  
  <div class="read-more-link">
    <a href="/post/3/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/2/">#2 [采坑指南] json.Unmarshal后interface{}成map[string]interface{}</a>
  </h1>
  <time datetime="2020-03-29T23:43:01&#43;0800" class="post-date">Sun, Mar 29, 2020</time>
  ​	可能大家工作中都会遇到类型断言，即接口类型断言是否为某种strcut类型i.(A)或某种struct的指针类型i.(*A)。
那么当一个想要一个interface{}类型既想转换成多种类型，且多种类型并不属于同一种。这句话说的可能比较绕圈，下面举个例子来看下。
当有两个SA和SB，当我们想要从字符串翻转成结构体时。我们可以
没问题，输出结果是
sa {logan 18 Beijing} PASS 但是当结构体内容时由其他结构体，以interface{}类型进行返回时，那么情景可能如下。
如果50和51行都注释掉了的话，那么结果会输出
it2 data type is map[string]interface {} ti3 type assertion error, it isn't type SA ti4 type assertion error, it isn't type SB ti5 is map[addr:Beijing age:18 name:logan] PASS 意味着data转换成了map[string]interface{}如果转换成map[string]interface{}类型后，那么想要key中的value还需要继续类型断言。
为什么会转成map[string]interface{}呢？因为对象底层类型，当unmarshal时并不知道对象底层类型。
那么，是否有一种希望转成的类型当我们的确希望转换成某种类型，如SA或SB。
答案是需要告诉结构类型的底层类型是什么，才可做此类型的类型断言。
解开注释50或51行后，则输出结果成为
it2 data type is *main.SB ti3 type assertion error, it isn't type SA ti4 is &amp;{logan 18 } ti5 type assertion error, it isn't type map[string]interface{} PASS 总结：当我们希望类型断言的结构体中是一个interface{}类型时，希望转换成某种我们希望的类型，要进行底层类型的转换。那么就要给Data进行赋值类型。则断言方可成功。
  
  <div class="read-more-link">
    <a href="/post/2/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/1/">#1 第一篇博客 &amp; 回顾我的大学</a>
  </h1>
  <time datetime="2020-03-22T15:48:01&#43;0800" class="post-date">Sun, Mar 22, 2020</time>
  ​	2020年3月21日晚，参加了Go夜读两周年的回顾。也是第82期的Go夜读share。虽然加入这个大家庭才不长时间，学习Golang这门语言也不是很久，因为之前做Java相关的工作。后期因为组织架构调整，公司要用Go去重写Java的服务，正因为如此，好些人都去转Go或离职。我也踏上了学习Golang的旅程。
 自述大学
 ​	我的大学专业是IOT，也就是物联网工程，一个软硬件都需要掌握的一个专业，我也相信是未来的趋势。但我从事了软件开发行业，也不知道算不算上所谓的”科班出身“。
​	大学大一度过的很”轻松加愉快“，仅参加了学校的《舞蹈社》（很奇怪，为什么一个Coder会参加舞蹈社，这可能与上高中之前的认知比较少有关吧，暂不讨论）。相反学习Software的知识比较少。
​	大二的我知道毕业时不能以在大学玩得好才能找到一份好工作的。后来经过我的DB老师的指导，自学了Java、JSP，记得当时大二的寒假，跟着老师去图书馆借了一本JSP相关的书籍，回家“啃”了起来。殊不知对于一个高中贪玩，大学以为“解放”了自己的我来说，啃书是多么的痛苦。正如我所料，我的进度比较慢，相当于把一本书分了40多份，每份是一天的消化的量。看完即完成了任务。这也是我自学之路的一个开始，但如今的我深知，如果自学都学不会的话，也不适合做Coder相关的工作。下学习又学了Java，DB等，但是看起来都只是学了个表面。
​	大三跟着老师做了个项目，名为《在线考试系统》，可想而知，在线考试系统即为学校教师出题，学生答题等一系列的相关的操作。这个项目做起来，很多的是在写业务，写逻辑。对于Spring原理来讲根本就没去了解。当时只记得一句话，‘在出校门的时候，自己有项目经历和没有项目经历完全是不一样的’。所以，乐此不疲的把这个项目做来做去。最终主要的功能也都做完了。相反，自己的DB底层原理，数据结构及算法和框架原理性的知识都被忽略了。后期才知道，毕业的春招和秋招对于应届生来讲，就考的是算法和数据结构和一些底层的原理知识。那么我一年多都是白干了么？不会吧？可能吧。不后悔不怪罪，这也是一个人渐渐成熟的体现吧。
​	大四有的同学继续考研，有的去找工作。我就是陷入了找工作的道路上。记得面试了20天左右。一个offer都没有收到，也正是我在家里的时候，IBM人力资源部给我打电话邀请我参加面试。我遍立刻答应了。一想IBM是外企大厂，以后说出去也有面子（当时无知的我）。可惜只是一个边缘部门吧。没学到什么知识，只了解的外企的文化（不加班就是个最大的特点）。所以，我觉得不能无为了，遍自学起了Java原理、设计模式、DB底层结构、Hadoop（HDFS、MapReduce）等。每日坚持9点去上班，23点才下班让的决心（当时我正式上班时间为下午2点到晚上11点，也腾出很多自学的时间）。后来请假去北京面试一周，最后也是来到了现在的公司，工作至今。
 未来的展望和建议
 ​	最后，想说这路上自己的认知发生的不断的变化。眼光看的也越来越长远了起来。想建议未来的我和其他的人，要把眼光放长远了。自己的路只能自己走，不要想着依赖谁，不要做“拿来党”，每个人都是时间都是有限的，不要辜负年轻时的自己。趁着年轻，多折腾折腾。
2020-03-22 18:07:13 于北京 马荣贺 Logan Ma
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://maronghe.github.io/post/aboutme/">关于我</a>
  </h1>
  <time datetime="2020-03-19T21:52:41&#43;0800" class="post-date">Thu, Mar 19, 2020</time>
   自我介绍
 ​	莫愁前方无知己，天下谁人不识君。
​	面试官您好，我叫马荣贺，毕业于&hellip;&hellip;..，目前就职于蓝信移动有限公司，从事服务端研发相关的工作。工作日常负责项目的评审、研发及后期的维护。
​	学习就要有节奏，有方向的进行。给自己顶一个短期计划，如三天，一周，半个月等。不能为了面试而学习这样只会让自己在临近工作做不下去，或想找工作之气临时抱佛脚。游戏切记成瘾！
​	学习是要有自我分析理解的过程，看网上的某些教程视频，人家仅会给你他理解到的内容，可能会有些不准确，也可能会有些偏差，当他给你讲述的同时，你可能理解有偏差。这样的话，你与其他人交流时，由于没有自己分析和摸索知识的过程，会显得格外的“虚”，不懂原理，不知其所以然。
​	所以学习还是要通过自己的一点一滴积累，寻求权威的认证，最不断地求知精神。同样在生活中多应该问问自己：“为什么？”，为什么这样做就可以，多思考，多探索。学习后要有些输出如博客等。也可以与组内和朋友交流，如果你能给其他人以通俗易懂的方式讲明白了。那么就证明你明白了。
​	分析问题的过程：
  为什么这么做？
  解决了哪些问题？
  逻辑和技术难点？
  自己做出了哪些事情？
如：『原因』系统为了解决用户的客户端APP连接会话不在线，同样可以将消息发送到对方手机上。「解决方案」从而引入了手机厂商的Push服务，可在用户登录时，端上调用手机厂商提供的结构，创建自己的手机的设备Token，将Token上传到自己的Server去维护。则服务端在发消息的同时可确定是否要发送系统Push来通知用户客户端。「性能提升」通过Push的接口的性能测试，可判别出Push服务的性能，从而发现性能瓶颈，解决和优化。
   计算机组成原理 操作系统 数据结构与算法 计算机网络（） 数据库原理 Go语言实现原理及新特性 Docker、K8S容器化、Service Mesh Redis、Kafka、ZK、ES、Nginx、Kibana、jenkins中间件 分布式、RPC、微服务链路追踪 网络安全攻击 性能测试 自定义协议  
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
