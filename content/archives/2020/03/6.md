---
title: "#6 GC"
date: 2020-03-23T16:38:02+08:00
draft: true

---

> GC分类：追踪式、引用计数式

- 追踪式，分为多种不同类型，例如：
  - 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
  - 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
  - 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
  - 增量整理：在增量式的基础上，增加对对象的整理过程。
  - 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。
- 引用数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。

> Go中使用的GC方式

Go使用无分代、不整理、并发的**<u>*三色标记清除法*</u>**（与用户代码并发执行）

Because:(反证法)

1. 对象整理的优势是为了解决内存碎片化的问题和顺序内存分配器。但Go采用[tcmalloc](tcmalloc)，基本上是没有碎片化的对象。顺序内存分配器在多线程下不适用。基于tcmalloc的内存分配算法，对于整理发来说，并不能得到实质的提升。
2. 分代回收基于*分代假设*，分代假设主要将基于回收精力放到新创建的对象上。而Go创建对象时会进行[逃逸分析](https://www.cnblogs.com/itbsl/p/10476674.html)会把对象尽量的分配到栈上，只有长时间存活的对象才会分配到堆上。那么goroutine死亡后，栈也会直接回收，不会参与GC，那么分代回收没有优势。
3. go采用与用户并发执行，则STW时间与对象的大小和是否分代，并没有直接关系。go团队使用更好的回收方式（部分CPU执行垃圾回收），而不把暂停回收时间作为唯一标准。



> 参考文献

https://mp.weixin.qq.com/s?__biz=MjM5MDUwNTQwMQ==&mid=2257484062&idx=1&sn=40a8cca15b9c215f8a29e60e6d8a3542&scene=21#wechat_redirect 

[tcmalloc]:<https://gperftools.github.io/gperftools/tcmalloc.html>