![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyyogfzwgj30od0bywf8.jpg)

8根 地址总线只有八位 即 1字节 【0,255】   256 是8根地址总线的最大寻址空间

32根                 32位      4G   最大寻址空间



每次操作4字节 （机器字长）就需要32位数据总线

​               8字节                            64位    



![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyyt79x3oj30o40buq4v.jpg)

内存并行访问 提高响应速度。得到逻辑连续内存。



![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyyv8o9slj30nu0a074s.jpg)

若想从 1 字节读取8个字节。CPU额外处理先读1-7 + 8 ，读取两次，会影响性能。

所以编译器会把各种类型放在合适的地址、合适的长度。-》 **内存对齐**。

每个类型都会有一个对应的 **对齐边界**。（要求数据存储地址，以及占用的字节数，都要是对其边界的倍数）

Int16   2 字节

Int32   4 字节 

![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyz0fd1cxj30rv0efjsy.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyz19falqj30o50fctax.jpg)

不同平台对齐边界不同。**<u>*数据类型对其边界 =  min（类型大小，平台最大对齐边界）*</u>**

![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyz6dozbkj30nq0cudiu.jpg)

为什么不采用 平台最大对齐边界或采用类型大小呢？

原因：1.内存浪费 或 

​	   	2.读取两次进行拼接  

		   3. 内存浪费更少，（32位 4 字节 存储 int64）如下图所示。
   		   4. ![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyzbrdlk9j30lh0dqgn2.jpg)



**结构体 内存对齐边界，取结构体中最大的类型对齐值，取最大的。**

![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyzcfwxzgj30mm08fgmg.jpg)

要求1：

 	1.	存储结构体地址，是对齐边界的倍数。
 	2.	存储地址addr ，当成地址0，然后用相对地址 计算自己的位置应当放在哪。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyzhqjxf2j30r70f5dim.jpg)

如果内存未对齐，

​			1.内存浪费

​	   	 2.读取两次进行拼接



![](https://tva1.sinaimg.cn/large/007S8ZIlly1geyzj3bmigj30oc0f1766.jpg)



结构体的大小保证是内存对齐的整数倍之后，才能保证数组中每个都是内存对齐的。

结构体如果补充过大的话，就可能会重新内存对齐。以节省空间。



int 是在不同的操作系统上占用的长度不一样，

64位系统中按照 int64

32位按照 int 32





