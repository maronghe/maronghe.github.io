DIstributed Cron Job In Micor 



定时任务几乎在所有的项目后台存在，可能在特定是时间执行一次或周期性的执行。



> 单机 

​	在单机中的服务中，一般定时任务是直截了当和简单的。

但是在多节点中的定时任务，通常可能有===任务重复执行和单点故障问题===。



1.一些’伙计‘将定时任务从守护进程中移到Web服务中并暴露API或RPC接口，然后触发器通过操作系统执行任务。或通过负载均衡，去请求一个节点。但是还是有单点故障问题。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gepuuebpi1j30jc0b1js5.jpg)

但是还是能同时解决 重复执行 和 单点故障问题。这正是面临的经典问题 ： Leader选举。

Micor 可以创建定时任务

``````go
  // get etcd node list from registry
   etcdList := service.Options().Registry.Options().Addrs
   // build leader
   lead := etcd.NewLeader(leader.Nodes(etcdList...))
   
   cron := sync.NewCron(sync.WithLeader(lead))
   cron.Schedule(
      task.Schedule{Interval: 10 * time.Second},
      task.Command{Name: "foo", Func: func() error {
         log.Info("finish command foo")
         return nil
      }},
   )
``````

Note： 其依赖 Etcd、zookeeper等分布式选举中间件。其实之前自己实现的通过Redis实现的分布式锁的逻辑，也是一个自我周期性获取Heath Check 和 抢占获取锁（选举当Leader）的过程。

``````go
task.Schedule => 就两个内容 -> 

// Schedule represents a time or interval at which a task should run
type Schedule struct {
   // When to start the schedule. Zero time means immediately
   Time time.Time
   // Non zero interval dictates an ongoing schedule
   Interval time.Duration
}

``````







> 服务熔断和限流



[hystrix](https://github.com/micro/go-plugins/tree/master/wrapper/breaker/hystrix) & [gobreaker](https://github.com/micro/go-plugins/tree/master/wrapper/breaker/gobreaker)

插件帮我们解决：

**DefaultMaxConcurrent** 是对于三个服务还还是3个不同的方法呢？

https://github.com/micro/go-plugins/blob/master/wrapper/breaker/hystrix/hystrix.go

``````go
func (c *clientWrapper) Call(ctx context.Context, req client.Request, rsp interface{}, opts ...client.CallOption) error {
	return hystrix.Do(req.Service()+"."+req.Endpoint(), func() error {
		return c.Client.Call(ctx, req, rsp, opts...)
	}, nil)
}


...
hystrix.ConfigureCommand("com.serviceA.methodFoo",
   hystrix.CommandConfig{
      MaxConcurrentRequests: 50, // 最大并发请求数 每个服务每个节点的每个方法
      Timeout:               10, // 超时时间
   })
hystrix.ConfigureCommand("com.serviceB.methodBar",
   hystrix.CommandConfig{
      Timeout: 60,
   })
...

// req.Service()+"."+req.Endpoint() 意味着服务和端点，并没有管节点的数量，
// so : each method of each service counts independently and does not affect each other.
// 每个服务的每个方法数量的限制，并不影响其他的。

``````



[Rate Limiter](https://github.com/micro/go-plugins/tree/master/wrapper/ratelimiter/uber)



``````go
package main
import (
   limiter "github.com/micro/go-plugins/wrapper/ratelimiter/uber/v2"
)
func main() {
   const QPS = 100
   // New Service
   service := micro.NewService(
      micro.Name("com.foo.srv.hello"),
      micro.Version("latest"),
      micro.WrapHandler(limiter.NewHandlerWrapper(QPS)), // 限制接口最大并发数
   )
}
``````



Final Worlds : 



The role of Circuit Breaker is to protect the client from being dragged down by external service issues and always respond quickly (even if you get an error, it is better than waiting for a long time). Always avoid excessive consumption of resources (避免过度消耗资源).

While the role of Rate Limiter is to protect the server. Only handle the traffic within its capacity to achieve overload protection. An error is returned immediately when the traffic exceeds the preset limit.





> ZooKeeper  （借鉴于文件系统）

1. Zookeeper 用于 分布式 系统中协调任务。
2. 任务可以是协作的（主给从分配任务）、也可以是竞争关系（竞争主节点争取执行权，实现互斥排他锁）。
3. 特性：
   1. 保证CAP中的CP（即强一致性，持久性（分区容错和顺序性））
   2. <u>实现通用的同步原语能力</u>？？？
   3. 提供简单的并发处理机制



Zookeeper :

1. setup /conf/zoo.cfg file. include port、dataDir、tickTime and so on.
2. ``bin/zkServer.sh start `` start a server.
3. ``bin/zkCli.sh -server 127.0.0.1:2181`` connect the local zk server.
4. ... ls / , create /my_zk hello , set /my_zk world , delete /my_zk ... For more [detail](https://zookeeper.apache.org/doc/current/zookeeperCLI.html).
5. 强烈建议zk集群节点为奇数，否则无法完成节点选取。（大于一半以上同意才能当成leader）
6. Finally, note the two port numbers after each server name: " 2888" and "3888". Peers use the former port to connect to other peers. Such a connection is necessary so that peers can communicate, for example, to agree upon the order of updates. More specifically, a ZooKeeper server uses this port to connect followers to the leader. When a new leader arises, a follower opens a TCP connection to the leader using this port. Because the default leader election also uses TCP, we currently require another port for leader election. This is the second port in the server entry.
7. 最后我们注意到有每个server都有两个端口号，**端口对等使用**。若需要保证一个必要的连接，以至于对等方可以通信。例如同意更新顺序，更特别的是，一个zk sever使用一个端口连接followers到leader。当一个新leader成立之后，一个从节点打开一个TCP连接到leader使用这个端口。因为leader的选举也是用过TCP，我们要求leader选举另外一个端口号，这就是第二个端口号在server entry中。
8. 总结一句话， 从节点一个端口用于连接TCP连接与主节点，当阶段选举时，也要用过端口使用TCP进行选举。



分布式锁中重要的特性之一是，如果节点获取锁后当`Carsh`后必须释放锁。

zookeeper 可以用过 `create -e /lock 's2:2228'`创建临时节点去加锁，正是利用了当session断开后，连接自动被删除的特性实现。同时，可以通过`watch`命令进行查看状态并监听`state -w /lock`，如果监听的节点断开后，会通知到监听节点一个`event`节点被删除的事件。



 

1. myid file is missing：

   需要在dataDir下创建myid文件并且需要在里面指定当前版本`1`

   

   zk 分布式锁，

   使用临时顺序节点 

   创建最小后缀数字znode的用户获取到锁。

   避免羊群效应。

   ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gerxfrtkfcj30ih07uwfj.jpg)

   ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gerxfztgjij311g0di0xg.jpg)

   watch前一个节点的状态，此锁还能遵循公平原则。先到的锁请求先处理。仅通知一个锁的等待者。避免通知所有。

   2 `watch` 1 , 3 `watch` 2 

`./bin/zkCli.sh -server 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183`

随机选取一个节点连接。

如果节点A（非住检点）宕机后，则客户端会收到一个事件(Event ， Closing Socket Exception)，则会从其他节点中选取一个进行连接。

如果一个主节点宕机之后从节点由于连接不上主节点之后会在仲裁模（Quorum）式下进行leader选举



``````
2020-05-14 17:05:20,780 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):ZooKeeperServer@329] - Created server with tickTime 2000 minSessionTimeout 4000 maxSessionTimeout 40000 clientPortListenBacklog -1 datadir /Users/logan/Documents/env/zookeeper3/data/version-2 snapdir /Users/logan/Documents/env/zookeeper3/data/version-2
2020-05-14 17:05:20,782 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):Leader@581] - LEADING - LEADER ELECTION TOOK - 221 MS
2020-05-14 17:05:20,783 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):QuorumPeer@863] - Peer state changed: leading - discovery
2020-05-14 17:05:20,784 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):FileTxnSnapLog@470] - Snapshotting: 0x900000007 to /Users/logan/Documents/env/zookeeper3/data/version-2/snapshot.900000007
2020-05-14 17:05:20,784 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):ZooKeeperServer@519] - Snapshot taken in 1 ms
2020-05-14 17:05:20,889 [myid:3] - INFO  [LearnerHandler-/127.0.0.1:59479:LearnerHandler@504] - Follower sid: 1 : info : 127.0.0.1:2777:3777:participant
2020-05-14 17:05:20,891 [myid:3] - INFO  [LearnerHandler-/127.0.0.1:59479:ZKDatabase@345] - On disk txn sync enabled with snapshotSizeFactor 0.33
2020-05-14 17:05:20,892 [myid:3] - INFO  [LearnerHandler-/127.0.0.1:59479:LearnerHandler@800] - Synchronizing with Learner sid: 1 maxCommittedLog=0x900000007 minCommittedLog=0x900000001 lastProcessedZxid=0x900000007 peerLastZxid=0x900000007
2020-05-14 17:05:20,892 [myid:3] - INFO  [LearnerHandler-/127.0.0.1:59479:LearnerHandler@845] - Sending DIFF zxid=0x900000007 for peer sid: 1
2020-05-14 17:05:20,892 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):QuorumPeer@863] - Peer state changed: leading - synchronization
2020-05-14 17:05:20,897 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):Leader@1501] - Have quorum of supporters, sids: [[1, 3],[1, 3]]; starting up and setting last processed zxid: 0xa00000000
2020-05-14 17:05:20,898 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):CommitProcessor@476] - Configuring CommitProcessor with readBatchSize -1 commitBatchSize 1
2020-05-14 17:05:20,899 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):CommitProcessor@438] - Configuring CommitProcessor with 12 worker threads.
2020-05-14 17:05:20,906 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):ContainerManager@83] - Using checkIntervalMs=60000 maxPerMinute=10000 maxNeverUsedIntervalMs=0
2020-05-14 17:05:20,908 [myid:3] - INFO  [QuorumPeer[myid=3](plain=[0:0:0:0:0:0:0:0]:2183)(secure=disabled):QuorumPeer@863] - Peer state changed: leading - broadcast
``````

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ges4rnks3qj31l20p6wsm.jpg)





`dataTree 保存在内容中 8G It fine.`

CPU不是性能的瓶颈，所以双核CPU就可以。存储设备的写延迟会直接影响事务的提交效率。所以建议分配一个独立的dataLogDir的SSD磁盘。



// zk监控 JMS + Prometheus

// Observe 实现 zk 跨区域部署，优化节点响应速度。 发送 forward 的等待 infor 

节点间的 propose、ack、commit消息跨区域



动态配置：[dynamic configuration](https://zookeeper.apache.org/doc/current/zookeeperReconfig.html#sc_reconfig_retrieving)

``````
服务发现
服务实例获取
服务反馈（Curator）
``````





``````
etcd 
k8s 服务发现 和 配置中心
OpenStack 配置中心 和 分布式锁
ROOK 编排引擎

zk datatree 需要加载到内存 几百兆
etcd bbolt 存储引擎 几个GB  k-v 存储

MVCC 
compaction reversion 进行整理和清除之前的版本
bbolt -> b+ tree  key : major + sub + type 
	1.major -> reversion
	2.sub -> 每次更新的key
	3.type 保存可选项的特殊值 （11 22 平台）
内存中还维护了一个btree，是key-value 中的 key


``````





`````
LSM Log Struct Merge-Tree
B+ Tree
And Compare with B+ Tre and LSM 
`````





// 1 简历与要求要高度匹配

// 2 体现自己能干活

// 3 体现自己非常愿意以正式员工并长久的留在大厂工作







> TODO

1. 基于Kubernetes的CICD的环境部署实施
2. 





Slice扩容规则

1.预估扩容后的容量 newCap -> 预估元素个数

​	如果 扩容前容量翻倍还是小于最小长度，那么就等于最小长度 oldCap * 2 < cap， **newCap = cap**

​	否则 如果扩容前长度(oldCap)小于1024 则 **newCap = oldCap * 2** 

​			 否则  >= 1024 则 扩容1/4 **newCap = oldCap * 1.25**

2.newCap个元素需多大内存？（与元素类型大小挂钩）

​	newCap * 元素大小 = 所需内存大小（并非直接向操作系统申请内存，与各语言内存管理模块有关）

3. 匹配合适的内存规格。Go内管理模块分为：8 ，16，32，48，64，80，96，112....

​	如 我要申请24字节内存，则 Go直接分配 32 字节内存。（匹配足够大且最接近的规格）

```

	s := []int{1, 2} // int 8 字节
	s = append(s, 3, 4, 5)

	// step 1  3 * 2 = 6
	// 5 > 4 = 5
	// 5 * 8 = 40 <= 48
	// 48 / 8 = 6
	fmt.Println(len(s))   // 5
	fmt.Println(cap(s))   // 6
	fmt.Printf("%p\n", s) // 0xc00001c180
	s = append(s, 6)
	fmt.Printf("%p\n", s) // 0xc00001c180

	fmt.Println(len(s)) // 6
	fmt.Println(cap(s)) // 6
```

 

```
a := []string{"my","name","is"} // 64位 16字节
a = append(a,"Logan")
// 3 * 2 > 4 , newCap = 6
// 16 * 6 = 96 字节
// newCap = 16


```



迁移不是从cell 0位置开始迁移的